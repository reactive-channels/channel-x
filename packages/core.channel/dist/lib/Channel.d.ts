import { BehaviorSubject, Observable, ReplaySubject } from "rxjs";
import { Broker } from "./broker/broker";
import { DataType } from "./types/DataType";
import { EmittersContainer } from "./types/EmittersContainer";
import { Endpoint } from "./types/Endpoint";
import { ExchangeType } from "./types/ExchangeType";
import { HttpInfo } from "./types/HttpInfo";
import { QueueItem } from "./types/QueueItem";
import { QueuesContainer } from "./types/QueuesContainer";
import { SubjectOptions } from "./utils/rx.utils";
export declare class Channel {
    private static readonly INIT_VALUE;
    protected static readonly _queues: QueuesContainer;
    static classForTestsOnly(queueName: string, stream: BehaviorSubject<unknown> | ReplaySubject<unknown>, options?: any): Channel;
    get propsForTestsOnly(): {
        queueName: string;
        queueContext: any;
        subscriptions: any[];
        operators: any;
        builders: any;
        tempData: any;
        queues: QueuesContainer;
        emitters: EmittersContainer;
        exchangeName: string;
        exchangeType: ExchangeType;
        httpInfo: HttpInfo;
    };
    static publishTo(queueName: string, msg: any): void;
    static consumeFrom(queueName: string): import("rxjs").Subject<any>;
    protected static broker: Broker;
    private static readonly exchanges;
    private options;
    static get settings(): {
        broker: Broker;
        context: any[];
    };
    private static context;
    private static refs;
    protected queueName: string;
    private queueContext;
    private subscriptions;
    protected operators: any;
    private builders;
    scope(context: any): this;
    private tempData;
    protected queues: QueuesContainer;
    protected emitters: EmittersContainer;
    private exchangeName;
    private exchangeType;
    protected httpInfo: HttpInfo;
    static use(queueName: string, options?: any): Channel;
    static useReplay(queueName: string, options?: any): Channel;
    static innerUse(queueName: string, options?: any): Channel;
    stash<T>(msg: T, type?: DataType, override?: boolean): void;
    stashAndPublishWhen(): string;
    flushAndPublish(): void;
    context(context: any): this;
    static getQueues(): QueuesContainer;
    static getExchanges(): {
        [key: string]: string[];
    };
    assertExchange(exchangeName: string, exchangeType?: ExchangeType): Channel;
    static subjectOptions: SubjectOptions;
    private setQueues;
    protected constructor(queueName: string, stream: BehaviorSubject<unknown> | ReplaySubject<unknown>, options?: any);
    close(): any;
    private clearChannelData;
    protected setEndpoint(endpoint: Endpoint | string, isCore?: boolean): Channel | HttpInfo;
    private pushToExchange;
    private pushToQueues;
    private pipeTransformers;
    private getHttpResult;
    private setMsg;
    publish<T>(msg?: T, cb?: VoidFunction): Promise<Channel>;
    pipe(pipes: any): Channel;
    tube(builder: any, functionBody: any): this;
    funnel(): this;
    private static clearSubscriptions;
    protected createStream(queueItem: QueueItem): any;
    consume<T>(action?: (...params: any[]) => any, subscribe?: boolean): Observable<T>;
    bindExchange(exchangeName: string, exchangeType?: ExchangeType): this;
}
